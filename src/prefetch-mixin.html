<link rel="import" href="entity-store.html">

<script>
	(function() {
		let prefetching = 0;
		const concurrency = 100;

		/*
			@polymerMixin
			Calls D2L.EntityStore.fetch for relevant subentities to be prefetched
			and listens for changes on subsequent subentities, prefetching as required

			The class needs to have the static property interesting defined

			static get interesting() {
				return [
					{
						// Returns an iterable of objects containing an 'href' property or strings
						getLinks: entity => entity.getSubEntitiesByRel('https://api.brightspace.com/rels/user-profile').map(entity => entity.getLinkByRel('self')),
						// An iterable of element constructors that in the template gets passed the links from getLinks and use PrefetchMixin
						elements: [window.customElements.get('d2l-user-image'), window.customElements.get('d2l-user-name')]
					},
					{ getLinks: entity => entity.getSubEntitiesByRel('alternate').map(entity => entity.href), elements: [window.customElements.get('x-alternate')] }
				];
			}
		*/
		PrefetchMixin = function(superClass) {
			const interestingListeners = new Set();
			return class extends superClass {
				_entityChanged(entity) {
					super._entityChanged(entity);
					this.constructor.beginPrefetch(this.entity, this.token);
				}

				static _prefetchForElements(entity, token, elements) {
					for (const interestingElement of elements) {
						interestingElement.beginPrefetch && interestingElement.beginPrefetch(entity, token);
					}
				}

				// fetch interesting entity and iterate through the elements
				static _doPrefetch(href, token, elements) {
					// limit the amount of requests we do at once
					if (prefetching >= concurrency) {
						Polymer.Async.idlePeriod.run(() => this._doPrefetch(href, token, elements));
						return;
					}

					console.debug(`prefetch "${href}" - start`);
					// actually do the fetch
					const fetchResult = D2L.EntityStore.fetch(href, token);

					if ( fetchResult.status === 'fetching') { // Wait for the entity, then prefetch for each element
						prefetching++;
						console.debug(`prefetch "${href}" - fetching`);
						const interestingListener = {
							href: href,
							token: token
						};

						interestingListener.listener = (interestingEntity) => {
							console.debug(`prefetch "${href}" - fetched`);
							console.debug(`prefetch "${href}" - removing listener`);
							interestingListeners.delete(interestingListener);
							D2L.EntityStore.removeListener(href, token, interestingListener.listener);
							prefetching--;
							console.debug(`prefetch "${href}" - starting next prefetch`);
							if (interestingEntity) {
								this._prefetchForElements(interestingEntity, token, elements);
							}
						};

						console.debug(`prefetch "${href}" - adding listener`);
						interestingListeners.add(interestingListener);
						D2L.EntityStore.addListener(href, token, interestingListener.listener);
					} else if ( fetchResult.status !== 'error' ) { // We have the entity. Just prefetch for each element
						console.debug(`prefetch "${href}" - fetched`);
						console.debug(`prefetch "${href}" - starting next prefetch`);
						this._prefetchForElements(fetchResult.entity, token, elements);
					}
				}

				static beginPrefetch(entity, token) {
					entity = window.D2L.Hypermedia.Siren.Parse(entity);

					// get interesting entities
					for (const { getLinks, elements } of this.interesting) {
						let links = getLinks(entity);
						if (!links) {
							continue;
						}
						if (typeof links === 'string' || !(Symbol.iterator in links)) {
							links = [links];
						}
						for (const link of links) {
							if (!link) {
								continue;
							}
							const href = link.href || link;
							if (!href) {
								continue;
							}

							Polymer.Async.idlePeriod.run(() => this._doPrefetch(href, token, elements));
						}
					}
				}
			};
		};
	})();
</script>
