<link rel="import" href="entity-store.html">

<script>
	(function() {
		/*
			@polymerMixin
			Calls D2L.EntityStore.fetch for relevant subentities to be prefetched
			and listens for changes on subsequent subentities, prefetching as required

			The class needs to have the static property interesting defined

			static get interesting() {
				return [
					{
						// Returns an iterable of objects containing an 'href' property or strings
						getLinks: entity => entity.getSubEntitiesByRel('https://api.brightspace.com/rels/user-profile').map(entity => entity.getLinkByRel('self')),
						// An iterable of element constructors that in the template gets passed the links from getLinks and use PrefetchMixin
						elements: [window.customElements.get('d2l-user-image'), window.customElements.get('d2l-user-name')]
					},
					{ getLinks: entity => entity.getSubEntitiesByRel('alternate').map(entity => entity.href), elements: [window.customElements.get('x-alternate')] }
				];
			}
		*/
		PrefetchMixin = function(superClass) {
			const interestingListeners = new Set();
			return class extends superClass {
				_entityChanged(entity) {
					super._entityChanged(entity);
					this.constructor.beginPrefetch(this.entity, this.token);
				}

				// fetch interesting entity and iterate through the constructors
				static _doPrefetch(href, token, elements) {
					console.debug(`prefetch "${href}" - start`);
					const fetchResult = D2L.EntityStore.fetch(href, token);
					for (const interestingElement of elements) {
						if ( fetchResult.status === 'fetching') {
							console.debug(`prefetch "${href}" - fetching`);
							const interestingListener = {
								href: href,
								token: token
							};
							interestingListener.listener = (interestingEntity) => {
								console.debug(`prefetch "${href}" - fetched`);
								console.debug(`prefetch "${href}" - removing listener`);
								interestingListeners.delete(interestingListener);
								D2L.EntityStore.removeListener(href, token, interestingListener.listener);
								console.debug(`prefetch "${href}" - starting next prefetch`);
								interestingElement.beginPrefetch && interestingElement.beginPrefetch(interestingEntity, token);
							};

							console.debug(`prefetch "${href}" - adding listener`);
							interestingListeners.add(interestingListener);
							D2L.EntityStore.addListener(href, token, interestingListener.listener);
						} else {
							console.debug(`prefetch "${href}" - fetched`);
							console.debug(`prefetch "${href}" - starting next prefetch`);
							interestingElement.beginPrefetch && interestingElement.beginPrefetch(fetchResult.entity, token);
						}
					}
				}

				static beginPrefetch(entity, token) {
					entity = window.D2L.Hypermedia.Siren.Parse(entity);

					// get interesting entities
					for (const { getLinks, elements } of this.interesting) {
						let links = getLinks(entity);
						if (!links) {
							continue;
						}
						if (typeof links === 'string' || !(Symbol.iterator in links)) {
							links = [links];
						}
						for (const link of links) {
							if (!link) {
								continue;
							}
							const href = link.href || link;
							if (!href) {
								continue;
							}

							Polymer.Async.idlePeriod.run(() => this._doPrefetch(href, token, elements));
						}
					}
				}
			};
		};
	})();
</script>
