<link rel="import" href="siren-parser.html">
<script>
(function() {
	'use strict';

	/*
		This store is hacked together to develop entity-mixin.
	*/
	const EntityStore = {

		_store: {},

		_listeners: {},

		addListener: function(entityId, listener) {

			if (!entityId || typeof listener !== 'function') {
				return;
			}

			let listeners = this._listeners[entityId];
			if (listeners) {
				if (listeners.indexOf(listener) !== -1) {
					return;
				}
			} else {
				this._listeners[entityId] = listeners = [];
			}

			listeners.push(listener);

		},

		fetch: function(entityId) {
			const entity = this._store[entityId];
			if (entity) {
				if (entity.status === 'fetching') {
					return;
				}
				this._notify(entityId, entity.entity);
			} else {
				// uh oh... we don't have it... quick, distract them
				this._store[entityId] = { 'status': 'fetching', 'entity': null };
			}
		},

		update: function(entityId, entity) {
			return new Promise((resolve) => {

				// fake it
				this._store[entityId] = { 'status': '', 'entity': entity };
				this._notify(entityId, entity);

				resolve(entity);

			});
		},

		removeListener: function(entityId, listener) {

			if (!entityId || typeof listener !== 'function') {
				return;
			}

			const listeners = this._listeners[entityId];
			const index = listeners.indexOf(listener);
			if (index === -1) {
				return;
			}

			// maybe just set null and clean up array in requestIdleCallback
			listeners.splice(index, 1);

		},

		_notify: function(entityId, entity) {
			entity = window.D2L.Hypermedia.Siren.Parse(entity);

			const listeners = this._listeners[entityId];
			if (listeners) {
				for (let i = 0; i < listeners.length; i++) {
					listeners[i](entity);
				}
			}
		}

	};

	window.D2L = window.D2L || {};
	window.D2L.EntityStore = EntityStore;

})();
</script>
<script type="text/javascript" src="../data/items.js"></script>
